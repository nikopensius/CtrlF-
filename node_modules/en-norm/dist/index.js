"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const contractions_rules_1 = require("./contractions_rules");
const en_lexicon_1 = require("en-lexicon");
function resolveContractions(string) {
    contractions_rules_1.contractionRules.forEach((rule) => {
        string = string.replace(rule.regex, rule.replacement);
    });
    return string.replace(/\s+/g, " ");
}
exports.resolveContractions = resolveContractions;
function replaceConfusables(string) {
    return string
        .replace(/[｀΄＇ˈˊᑊˋꞌᛌ‘’י՚‛՝`'′׳´ʹ˴ߴ‵ߵʻʼ᾽ʽ῾ʾ᾿]/g, "'")
        .replace(/["＂〃ˮײ᳓″״‶˶ʺ“”˝‟]/g, '"');
}
exports.replaceConfusables = replaceConfusables;
function normalizeCaps(tokens) {
    if (isAllCaps(tokens.join(""))) {
        tokens = tokens.map((token) => {
            if (isProper(token))
                return capitalizeFirstChar(token);
            else
                return token.toLowerCase();
        });
    }
    else if (!isProper(tokens[0]))
        tokens[0] = tokens[0].toLowerCase();
    return tokens;
}
exports.normalizeCaps = normalizeCaps;
function capitalizeFirstChar(string) {
    return string.charAt(0).toUpperCase() + string.substr(1).toLowerCase();
}
function isAllCaps(string) {
    const sentenceLength = string.length;
    const capsLetters = string.split(/[A-Z]/).length;
    return Math.round((capsLetters * 100) / sentenceLength) > 50;
}
function isProper(string) {
    if ((en_lexicon_1.lexicon[capitalizeFirstChar(string)] || "").startsWith("NNP") || (en_lexicon_1.lexicon[string] || "").startsWith("NNP"))
        return true;
    else
        return false;
}
