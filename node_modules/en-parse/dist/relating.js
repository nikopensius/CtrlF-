"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const relationships_1 = require("./rules/relationships");
const en_inflectors_1 = require("en-inflectors");
function default_1(nodes, recursionLimit) {
    nodes = identifyRoot(nodes);
    nodes = buildRelationships(nodes, recursionLimit);
    return nodes;
}
exports.default = default_1;
;
function identifyRoot(nodes) {
    let marked = false;
    function markAsRoot(index) {
        marked = true;
        nodes[index].label = "ROOT";
    }
    const removedADs = [];
    const roots = [];
    for (var index = 0; index < nodes.length; index++) {
        let node = nodes[index];
        if (node.type === "AD")
            continue;
        removedADs.push({
            index: index,
            node: node
        });
    }
    for (var index = 0; index < removedADs.length; index++) {
        let node = removedADs[index];
        if ((roots.length) && (index - roots[roots.length - 1].index > 4))
            break;
        if (node.node.tags[0].startsWith("V"))
            roots.push({
                base: new en_inflectors_1.Inflectors(node.node.tokens[0]).toPresent(),
                token: node.node.tokens[0].toLowerCase(),
                index: node.index
            });
    }
    if (roots.length === 0)
        return nodes;
    if ((!marked) && roots.length > 3) {
        if (roots[0].base === "will" && roots[1].base === "have" && roots[2].token === "been") {
            markAsRoot(roots[3].index);
        }
    }
    if ((!marked) && roots.length > 2) {
        if (roots[0].base === "have" && roots[1].token === "been")
            markAsRoot(roots[2].index);
        else if (roots[0].base === "will" && roots[1].base === "have")
            markAsRoot(roots[2].index);
        else if (roots[0].base === "be" && roots[1].token === "going" && nodes[roots[1].index + 1].tokens[0] === "to") {
            markAsRoot(roots[2].index);
        }
    }
    if ((!marked) && roots.length > 1) {
        if (roots[0].base === "do" || roots[0].base === "be" || roots[0].base === "have") {
            markAsRoot(roots[1].index);
        }
    }
    if ((!marked) && roots.length > 0)
        markAsRoot(roots[0].index);
    return nodes;
}
function buildRelationships(nodes, recursionLimit) {
    let iteration = 0;
    while (iteration < recursionLimit && nodes.length > 1) {
        for (var l = nodes.length - 2; l >= 0; l--) {
            var leftNode = nodes[l];
            var rightNode = nodes[l + 1];
            var match = matchNodes(leftNode, rightNode, iteration);
            if (!match)
                continue;
            if (match.direction === "<-") {
                rightNode.label = match.label;
                leftNode.right.push(rightNode);
                nodes.splice(l + 1, 1);
            }
            else if (match.direction === "->") {
                leftNode.label = match.label;
                rightNode.left.push(leftNode);
                nodes.splice(l, 1);
            }
        }
        iteration += 1;
    }
    return nodes;
}
function matchNodes(left, right, iteration) {
    let match = null;
    for (let i = 0; i < relationships_1.relationships.length; i++) {
        let rel = relationships_1.relationships[i];
        if (rel.left.length && rel.left.indexOf(left.type) === -1)
            continue;
        else if (rel.right.length && rel.right.indexOf(right.type) === -1)
            continue;
        else if (rel.delay !== -1 && iteration <= rel.delay)
            continue;
        else if (rel.maxDistance !== -1 && ((right.index[0] - left.index[1]) - 1) > rel.maxDistance)
            continue;
        else if (rel.direction === "<-" && right.label === "ROOT")
            continue;
        else if (rel.direction === "->" && left.label === "ROOT")
            continue;
        else if (rel.label === "NSUBJ" && rel.direction === "->" && exports.findBy.label("NSUBJ", right.left))
            continue;
        else if (rel.label === "NSUBJPASS" && rel.direction === "->" && exports.findBy.label("NSUBJPASS", right.left))
            continue;
        else if (rel.leftTokens.length && rel.leftTokens.indexOf(new en_inflectors_1.Inflectors(left.tokens[0]).conjugate("VBP")) === -1)
            continue;
        else if (rel.rightTokens.length && rel.rightTokens.indexOf(new en_inflectors_1.Inflectors(right.tokens[0]).conjugate("VBP")) === -1)
            continue;
        else {
            match = rel;
            break;
        }
        ;
    }
    if (!match)
        return false;
    return {
        direction: match.direction,
        label: match.label
    };
}
;
exports.findBy = {
    type: function (type, nodes) {
        return !!nodes.find((node) => node.type === type);
    },
    label: function (label, nodes) {
        return !!nodes.find((node) => node.label === label);
    },
};
