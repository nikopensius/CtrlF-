/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/content.js":
/*!************************!*\
  !*** ./src/content.js ***!
  \************************/
/***/ (() => {

eval("function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nvar STOP_WORDS = ['a', 'an', 'and', 'are', 'as', 'at', 'be', 'but', 'by', 'for', 'if', 'in', 'into', 'is', 'it', 'no', 'not', 'of', 'on', 'or', 'such', 'that', 'the', 'their', 'then', 'there', 'these', 'they', 'this', 'to', 'was', 'will', 'with'];\nfunction processTextContent(text) {\n  text = text.trim();\n  // Idea for quick bug fix \"rabbits7\": '' -> ' '\n  text = text.replace(/[^\\w\\s]/g, ' '); // Remove all non-word and non-space characters\n  text = text.replace(/\\s+/g, ' ');\n  text = text.toLowerCase();\n  /*\r\n  TODO: Return an array of sentences? instead of array of words\r\n        It will be used by backend to tokenize sentence into tokens and then lemmatize.\r\n  Return should be *sentences* not *words*\r\n  */\n  var words = text.split(' ').filter(function (word) {\n    return !STOP_WORDS.includes(word);\n  });\n  return words;\n}\nfunction getDOMText() {\n  var selector = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'p';\n  var root = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : document;\n  var elementsToExtract = [\"p\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"div\"];\n  var inv_index_paragraphs = {};\n  var highlight_paragraphs = {};\n  var html = document.querySelector('body').innerHTML;\n  elementsToExtract.forEach(function (elementType) {\n    var regex = new RegExp(\"<\".concat(elementType, \"[^>]*>(.*?)</\").concat(elementType, \">\"), 'gs');\n    var match;\n    while ((match = regex.exec(html)) !== null) {\n      var text = match[1].replace(/<[^>]+>/g, '');\n      var documentId = elementType + '_' + Object.keys(highlight_paragraphs).length;\n      highlight_paragraphs[documentId] = match[1];\n      inv_index_paragraphs[documentId] = text;\n    }\n  });\n  return {\n    highlightParagraphs: highlight_paragraphs,\n    invIndexParagraphs: inv_index_paragraphs\n  };\n}\nvar paragraphs_and_ids = [];\nchrome.runtime.onMessage.addListener(function (message, sender, sendResponse) {\n  if (message.action === 'getDocuments') {\n    var _getDOMText = getDOMText(),\n      highlightParagraphs = _getDOMText.highlightParagraphs,\n      invIndexParagraphs = _getDOMText.invIndexParagraphs;\n    console.log(\"Inv index paragraphs:\", invIndexParagraphs);\n    paragraphs_and_ids = highlightParagraphs;\n    sendResponse(invIndexParagraphs);\n  }\n});\nfunction filterParagraphs(paragraphs, idsToHighlight) {\n  var textToHighlight = [];\n  var _iterator = _createForOfIteratorHelper(idsToHighlight),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var paragraphId = _step.value;\n      var text = paragraphs[paragraphId];\n      if (text) {\n        textToHighlight.push(text);\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return textToHighlight;\n}\n\n//remove any previous highlighting using span element unwrapping\nfunction removePreviousHighlighting() {\n  var highlightedSpans = document.querySelectorAll('.highlight');\n  highlightedSpans.forEach(function (span) {\n    var parent = span.parentNode;\n    while (span.firstChild) {\n      parent.insertBefore(span.firstChild, span);\n    }\n    parent.removeChild(span);\n  });\n}\nvar paragraphIds = []; // Array to store the paragraphIds\nvar currentIndex = -1; // Current index of the highlighted paragraph\n\nfunction highlightText(paragraphsToHighlight) {\n  // Reset the paragraphIds and currentIndex\n  paragraphIds = [];\n  currentIndex = -1;\n\n  // Create a <style> element\n  var styleElement = document.createElement('style');\n\n  // Set the CSS rule\n  var cssRule = '.highlight { background-color: yellow; }';\n\n  // Add the CSS rule to the <style> element\n  styleElement.appendChild(document.createTextNode(cssRule));\n\n  // Append the <style> element to the <head> section\n  document.head.appendChild(styleElement);\n  removePreviousHighlighting();\n  var body = document.querySelector('body');\n  var html = body.innerHTML;\n  paragraphsToHighlight.forEach(function (paragraph, index) {\n    var paragraphId = \"highlighted-section-\".concat(index + 1);\n    var regex = new RegExp(escapeRegExp(paragraph), 'gi');\n    html = html.replace(regex, \"<span id=\\\"\".concat(paragraphId, \"\\\" class=\\\"highlight\\\">\").concat(paragraph, \"</span>\"));\n    paragraphIds.push(paragraphId);\n  });\n  body.innerHTML = html;\n}\n\n// Function to escape special characters in a string for use in a regular expression\nfunction escapeRegExp(string) {\n  return string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}\n\n// Define the function that handles the Enter keypress event\nfunction handleFindInputEnter(event) {\n  if (event.target && event.target.id === 'tfidf-findbar-input' && event.key === 'Enter') {\n    var findInput = document.getElementById('tfidf-findbar-input');\n    var searchString = findInput.value.trim();\n    // Send message to background script with user query\n    chrome.runtime.sendMessage({\n      action: 'userQuery',\n      payload: searchString\n    }, function (response) {\n      console.log(response);\n      var paragraphsToHighlight = filterParagraphs(paragraphs_and_ids, response);\n      highlightText(paragraphsToHighlight);\n      if (paragraphsToHighlight.length > 0) {\n        navigateToNext();\n      }\n      updatePositionCount();\n    });\n  }\n}\n\n// Listen for keypress events on the document and delegate to the find input\ndocument.addEventListener('keypress', handleFindInputEnter);\n\n// Listen for click events on the document and delegate to the findbar close button\ndocument.addEventListener('click', function (event) {\n  if (event.target && event.target.id === 'tfidf-findbar-close') {\n    // Remove the findbar from the DOM\n    var findbar = document.getElementById('tfidf-findbar');\n    if (findbar) {\n      removePreviousHighlighting();\n      findbar.remove();\n    }\n  }\n});\ndocument.addEventListener('click', function (event) {\n  if (event.target && event.target.id === 'tfidf-findbar-previous') {\n    navigateToPrevious();\n  }\n});\ndocument.addEventListener('click', function (event) {\n  if (event.target && event.target.id === 'tfidf-findbar-next') {\n    navigateToNext();\n  }\n});\n\n// Event listener for \"Esc\" key press\ndocument.addEventListener('keydown', function (event) {\n  if (event.key === 'Escape') {\n    var findbar = document.getElementById('tfidf-findbar');\n    if (findbar && findbar.style.display !== 'none') {\n      removePreviousHighlighting();\n      findbar.remove();\n    }\n  }\n});\nfunction scrollToParagraph(paragraphId) {\n  var paragraphElement = document.getElementById(paragraphId);\n  if (paragraphElement) {\n    paragraphElement.scrollIntoView({\n      behavior: 'smooth'\n    });\n  }\n}\nfunction navigateToPrevious() {\n  if (currentIndex > 0) {\n    currentIndex--;\n    scrollToParagraph(paragraphIds[currentIndex]);\n    updatePositionCount();\n  }\n}\nfunction navigateToNext() {\n  if (currentIndex < paragraphIds.length - 1) {\n    currentIndex++;\n    scrollToParagraph(paragraphIds[currentIndex]);\n    updatePositionCount();\n  }\n}\nfunction updatePositionCount() {\n  var positionCountElement = document.getElementById('tfidf-findbar-position');\n  positionCountElement.textContent = \"\".concat(currentIndex + 1, \"/\").concat(paragraphIds.length);\n}\n\n// Function to inject the find bar into the DOM\nfunction injectFindBar() {\n  // Check if the find bar already exists\n  if (document.getElementById('tfidf-findbar')) {\n    return;\n  }\n\n  // Inject the find bar into the DOM\n  var findbar = document.createElement('div');\n  findbar.id = 'tfidf-findbar';\n  findbar.innerHTML = \"\\n  <div id=\\\"tfidf-findbar\\\" style=\\\"position: fixed; top: 0; right: 0; width: 300px; padding: 10px; background-color: #fff; border-radius: 10px; border: 1px solid #ccc; box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.1); z-index: 9999; display: flex; align-items: center;\\\">\\n  <input type=\\\"text\\\" id=\\\"tfidf-findbar-input\\\" placeholder=\\\"Insert keywords and hit Enter\\\" autofocus style=\\\"border: none; outline: none; flex: 1; margin-right: 5px;\\\" autocomplete=\\\"off\\\">\\n  <div style=\\\"display: flex; align-items: center; margin-right: 5px;\\\">\\n    <div id=\\\"tfidf-findbar-position\\\" style=\\\"font-size: 14px; margin-right: 5px;\\\"></div>\\n    <button id=\\\"tfidf-findbar-previous\\\" style=\\\"border: none; background-color: #fff; cursor: pointer;\\\">&#9650;</button>\\n    <button id=\\\"tfidf-findbar-next\\\" style=\\\"border: none; background-color: #fff; cursor: pointer;\\\">&#9660;</button>\\n  </div>\\n  <button id=\\\"tfidf-findbar-close\\\" style=\\\"font-weight: bold; border: none; background-color: #fff; cursor: pointer;\\\">X</button>\\n</div>\\n\\n  \"\n  /*\r\n    */;\n\n  document.body.appendChild(findbar);\n}\n\n// Listen for messages from the background script\nchrome.runtime.onMessage.addListener(function (message, sender, sendResponse) {\n  if (message.action === 'injectFindBar') {\n    injectFindBar();\n    // Focus the input field\n    document.getElementById('tfidf-findbar-input').focus();\n    sendResponse();\n  }\n});\n\n//# sourceURL=webpack://ctrlf-/./src/content.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__["./src/content.js"]();
/******/ 	
/******/ })()
;